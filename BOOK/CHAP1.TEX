\chapter{绪论}
\thispagestyle{empty}

\setlength{\fboxrule}{0pt}\setlength{\fboxsep}{0cm}
\noindent\color{blueblack}\shadowbox{
\begin{tabular}{|p{13.8cm}|}\arrayrulecolor{darkblue}\hline
\rowcolor{darkblue} \hei\textcolor{white}{Goals to Achieve}\\\hline
\rowcolor{lightblue}~~~~~~~~\kai\textcolor{darkblue}{1.~~ unordered\_map．}\\
%\rowcolor{lightblue}~~~~~~~~\kai\textcolor{darkblue}{2.~~ 了解数值计算方法的研究内容和特点．}\\
%\rowcolor{lightblue}~~~~~~~~\kai\textcolor{darkblue}{3.~~ 理解数值计算误差的有关概念．}\\
%\rowcolor{lightblue}~~~~~~~~\kai\textcolor{darkblue}{4.~~ 掌握数值计算误差的控制方法．}\\\hline
\end{tabular}}\color{black}
\setlength{\fboxrule}{1pt}\setlength{\fboxsep}{4pt}
%\setlength{\fboxrule}{0pt}\setlength{\fboxsep}{0cm}
%\shadowbox{
%\begin{tcolorbox}[arc=0mm,colback=white,colframe=darkblue,title= 学习目标与要求]
%\kai\textcolor{darkblue}{1.~~了解科学计算的一般过程．}\\
%\kai\textcolor{darkblue}{2.~~了解数值计算方法的研究内容和特点．}\\
%\kai\textcolor{darkblue}{3.~~理解数值计算误差的有关概念．}\\
%\kai\textcolor{darkblue}{4.~~掌握数值计算误差的控制方法．}
%\end{tcolorbox}}
%\setlength{\fboxrule}{1pt}\setlength{\fboxsep}{4pt}

\section{两数之和 unordered\_map}
\definibox{问题描述}{
\noindent 给定一个整数数组\textbf{nums} 和一个目标值\textbf{target}, 请你在该数组中找出和为目标值的那两个整数, 并返回他们的数组下标. 你可以假设每种输入只会对应一个答案. 但是, 你不能重复利用这个数组中同样的元素.\\
示例: 给定 nums = [2, 7, 11, 15], target = 9; 因为 nums[0] + nums[1] = 2 + 7 = 9;

\noindent 所以返回 [0, 1]

\noindent \url{https://leetcode-cn.com/problems/two-sum}}
\subsection{解题思路}
这里用c++的unordered\_map来解决, unordered\_map内部是一个关联容器, 采用hash 表结构, 有快速检索的功能.

哈希表是通过key关键字直接访问对应value值的数据结构. 特点是键和值一一对应, 查找时间复杂度\textbf{O(1)}.

Example\_1: unordered\_map插入, 迭代遍历.

{\color{red}{\emph{unordered\_map example\_1 code}}}
\begin{lstlisting}
#include <iostream>
#include <unordered_map>
#include <string>
using namespace std;
int main()
{
	unordered_map<string, double> umap;
	umap["PI"] = 3.14;
	umap.insert(make_pair("a", 2.1));

	// find in umap
	string key = "PI";
	if (umap.find(key) == umap.end())
		cout << "cannot find PI" << endl;
	else
		cout << "find " << umap.find(key)->first << " = " << umap.find(key)->second << endl;

	// iterator of umap
	cout << "entire unorded_map is:"<<endl;
	unordered_map<string, double>::iterator itr;
	for (itr = umap.begin(); itr != umap.end(); ++itr)
		cout << "(" << itr->first << "," << itr->second << ")" << endl;
	system("pause");
	return 0;
}
\end{lstlisting}
\noindent 
\fbox{%
  \parbox{0.3\textwidth}{
\textbf{output}:\\
find PI = 3\\
all elements are:\\
(PI,3.14)\\
(a,2.1)  
}}


Example\_2: 利用unordered\_map输出一段文字中重复单词的个数

{\color{red}{\emph{unordered\_map example\_2 code}}}
\begin{lstlisting}
#include <iostream>
#include <unordered_map>
#include <string>
#include <sstream>

using namespace std;

void printWordFreq(const string& str)
{
	unordered_map<string, int> wordFreq;
	string word;
	stringstream  ss(str);
	while (ss >> word)
		wordFreq[word]++;

	cout << "all elements are:" << endl;
	for (auto u : wordFreq)
		cout << "(" << u.first << "," << u.second << ")" << endl;
}

int main()
{
	string str = "studies very very hard";
	printWordFreq(str);
	return 0;
}
\end{lstlisting}
\noindent
\fbox{%
  \parbox{0.3\textwidth}{
\textbf{output}:\\
all elements are:\\
(studies, 1)\\
(very, 2)\\
(hard, 1)
}}

\subsection{解题代码}
\begin{lstlisting}
#include <iostream>
#include <unordered_map>
#include <vector>
using namespace std;

vector<int> twoSum(vector<int>& nums, int target)
{
    unordered_map<int, int> map;
    vector<int> result={};
    int n = (int)nums.size();
    for(int i = 0; i < n; ++i) {
        auto p = map.find(target-nums[i]);
        if(p != map.end()) {
        result.push_back(p->second);
        result.push_back(i);
        }
    map[nums[i]] = i;
    }
    return result;
}

int main()
{
    vector< int > nums = {2,7,11,15};
    vector<int> result;
    result = twoSum(nums,9);
    cout<<"["<<result[0] << "," <<result[1]<<"]"<<endl;
    return 0;
}
\end{lstlisting}



\section{两数相加 linked list}
\definibox{问题描述}{
\noindent 给出两个非空的链表用来表示两个非负的整数. 其中, 它们各自的位数是按照逆序的方式存储的, 并且它们的每个节点只能存储一位数字. 如果, 我们将这两个数相加起来, 则会返回一个新的链表来表示它们的和.

\noindent 您可以假设除了数字0之外, 这两个数都不会以0开头.

\noindent 示例: 输入 (2 $->$ 4 $->$ 3) + (5 $->$ 6 $->$ 4), 输出: 7 $->$ 0 $->$ 8, 原因: $342 + 465 = 807$

\noindent \url{https://leetcode-cn.com/problems/add-two-numbers}
}

\subsection{解题思路}
这里用c++ 链表来解决

Example\_1: 创建链表并初始化

{\color{red}{\emph{linked list example\_1 code}}}
\begin{lstlisting}
#include <iostream>

using namespace std;

class Node{
public:
	int data;
	Node* next;
};

int main()
{
	Node* head = nullptr;
	Node* second = nullptr;
	Node* third = nullptr;

	head = new Node();
	head->data = 1;

	second = new Node();
	second->data = 2;

	third = new Node();
	third->data = 3;

	cout << head->data << " " << second->data << " " << third->data << endl;

	delete head;
	delete second;
	delete third;
	return 0;
}
\end{lstlisting}
\noindent
\fbox{%
  \parbox{0.3\textwidth}{
\textbf{output}:\\
1 2 3
}}


Example\_2: 打印链表中的所有元素

{\color{red}{\emph{linked list example\_2 code}}}
\begin{lstlisting}
#include <iostream>

using namespace std;

class Node{
public:
	int data;
	Node* next;
};

void PrintLinkedList(Node* head)
{
	Node* temp = head;
	while (temp != nullptr) {
		cout << temp->data << " ";
		temp = temp->next;
	}
	cout << endl;
}

int main()
{
	Node* head = nullptr;
	Node* second = nullptr;
	Node* third = nullptr;

	head = new Node();
	second = new Node();
	third = new Node();

	head->data = 1;
	head->next = second;
	
	second->data = 2;
	second->next = third;
	
	third->data = 3;
	third->next = nullptr;


	PrintLinkedList(head);

	delete head;
	delete second;
	delete third;
	return 0;
}
\end{lstlisting}
\noindent
\fbox{%
  \parbox{0.3\textwidth}{
\textbf{output}:\\
1 2 3
}}

\subsection{解题代码}

