\chapter{绪论}
\thispagestyle{empty}

\setlength{\fboxrule}{0pt}\setlength{\fboxsep}{0cm}
\noindent\color{blueblack}\shadowbox{
\begin{tabular}{|p{13.8cm}|}\arrayrulecolor{darkblue}\hline
\rowcolor{darkblue} \hei\textcolor{white}{Goals to Achieve}\\\hline
\rowcolor{lightblue}~~~~~~~~\kai\textcolor{darkblue}{1.~~ unordered\_map．}\\
%\rowcolor{lightblue}~~~~~~~~\kai\textcolor{darkblue}{2.~~ 了解数值计算方法的研究内容和特点．}\\
%\rowcolor{lightblue}~~~~~~~~\kai\textcolor{darkblue}{3.~~ 理解数值计算误差的有关概念．}\\
%\rowcolor{lightblue}~~~~~~~~\kai\textcolor{darkblue}{4.~~ 掌握数值计算误差的控制方法．}\\\hline
\end{tabular}}\color{black}
\setlength{\fboxrule}{1pt}\setlength{\fboxsep}{4pt}
%\setlength{\fboxrule}{0pt}\setlength{\fboxsep}{0cm}
%\shadowbox{
%\begin{tcolorbox}[arc=0mm,colback=white,colframe=darkblue,title= 学习目标与要求]
%\kai\textcolor{darkblue}{1.~~了解科学计算的一般过程．}\\
%\kai\textcolor{darkblue}{2.~~了解数值计算方法的研究内容和特点．}\\
%\kai\textcolor{darkblue}{3.~~理解数值计算误差的有关概念．}\\
%\kai\textcolor{darkblue}{4.~~掌握数值计算误差的控制方法．}
%\end{tcolorbox}}
%\setlength{\fboxrule}{1pt}\setlength{\fboxsep}{4pt}

\section{两数之和 unordered\_map}
\definibox{问题描述}{
\noindent 给定一个整数数组\textbf{nums} 和一个目标值\textbf{target}, 请你在该数组中找出和为目标值的那两个整数, 并返回他们的数组下标. 你可以假设每种输入只会对应一个答案. 但是, 你不能重复利用这个数组中同样的元素.\\
示例: 给定 nums = [2, 7, 11, 15], target = 9; 因为 nums[0] + nums[1] = 2 + 7 = 9;

\noindent 所以返回 [0, 1]

\noindent \url{https://leetcode-cn.com/problems/two-sum}}
\subsection{解题思路}
这里用c++的unordered\_map来解决, unordered\_map内部是一个关联容器, 采用hash 表结构, 有快速检索的功能.

哈希表是通过key关键字直接访问对应value值的数据结构. 特点是键和值一一对应, 查找时间复杂度\textbf{O(1)}.

Example\_1: unordered\_map插入, 迭代遍历.

{\color{red}{\emph{unordered\_map example\_1 code}}}
\begin{lstlisting}
#include <iostream>
#include <unordered_map>
#include <string>
using namespace std;
int main()
{
	unordered_map<string, double> umap;
	umap["PI"] = 3.14;
	umap.insert(make_pair("a", 2.1));

	// find in umap
	string key = "PI";
	if (umap.find(key) == umap.end())
		cout << "cannot find PI" << endl;
	else
		cout << "find " << umap.find(key)->first << " = " << umap.find(key)->second << endl;

	// iterator of umap
	cout << "entire unorded_map is:"<<endl;
	unordered_map<string, double>::iterator itr;
	for (itr = umap.begin(); itr != umap.end(); ++itr)
		cout << "(" << itr->first << "," << itr->second << ")" << endl;
	system("pause");
	return 0;
}
\end{lstlisting}
\noindent 
\fbox{%
  \parbox{0.3\textwidth}{
\textbf{output}:\\
find PI = 3\\
all elements are:\\
(PI,3.14)\\
(a,2.1)  
}}


Example\_2: 利用unordered\_map输出一段文字中重复单词的个数

{\color{red}{\emph{unordered\_map example\_2 code}}}
\begin{lstlisting}
#include <iostream>
#include <unordered_map>
#include <string>
#include <sstream>

using namespace std;

void printWordFreq(const string& str)
{
	unordered_map<string, int> wordFreq;
	string word;
	stringstream  ss(str);
	while (ss >> word)
		wordFreq[word]++;

	cout << "all elements are:" << endl;
	for (auto u : wordFreq)
		cout << "(" << u.first << "," << u.second << ")" << endl;
}

int main()
{
	string str = "studies very very hard";
	printWordFreq(str);
	return 0;
}
\end{lstlisting}
\noindent
\fbox{%
  \parbox{0.3\textwidth}{
\textbf{output}:\\
all elements are:\\
(studies, 1)\\
(very, 2)\\
(hard, 1)
}}

\subsection{解题代码}
\begin{lstlisting}
#include <iostream>
#include <unordered_map>
#include <vector>
using namespace std;

vector<int> twoSum(vector<int>& nums, int target)
{
    unordered_map<int, int> map;
    vector<int> result={};
    int n = (int)nums.size();
    for(int i = 0; i < n; ++i) {
        auto p = map.find(target-nums[i]);
        if(p != map.end()) {
        result.push_back(p->second);
        result.push_back(i);
        }
    map[nums[i]] = i;
    }
    return result;
}

int main()
{
    vector< int > nums = {2,7,11,15};
    vector<int> result;
    result = twoSum(nums,9);
    cout<<"["<<result[0] << "," <<result[1]<<"]"<<endl;
    return 0;
}
\end{lstlisting}



\section{两数相加 linked list}
\definibox{问题描述}{
\noindent 给出两个非空的链表用来表示两个非负的整数. 其中, 它们各自的位数是按照逆序的方式存储的, 并且它们的每个节点只能存储一位数字. 如果, 我们将这两个数相加起来, 则会返回一个新的链表来表示它们的和.

\noindent 您可以假设除了数字0之外, 这两个数都不会以0开头.

\noindent 示例: 输入 (2 $->$ 4 $->$ 3) + (5 $->$ 6 $->$ 4), 输出: 7 $->$ 0 $->$ 8, 原因: $342 + 465 = 807$

\noindent \url{https://leetcode-cn.com/problems/add-two-numbers}
}

\subsection{解题思路}
这里用c++ 链表来解决

Example\_1: 创建链表并初始化

{\color{red}{\emph{linked list example\_1 code}}}
\begin{lstlisting}
#include <iostream>

using namespace std;

class Node{
public:
	int data;
	Node* next;
};

int main()
{
	Node* head = nullptr;
	Node* second = nullptr;
	Node* third = nullptr;

	head = new Node();
	head->data = 1;

	second = new Node();
	second->data = 2;

	third = new Node();
	third->data = 3;

	cout << head->data << " " << second->data << " " << third->data << endl;

	delete head;
	delete second;
	delete third;
	return 0;
}
\end{lstlisting}
\noindent
\fbox{%
  \parbox{0.3\textwidth}{
\textbf{output}:\\
1 2 3
}}


Example\_2: 打印链表中的所有元素

{\color{red}{\emph{linked list example\_2 code}}}
\begin{lstlisting}
#include <iostream>

using namespace std;

class Node{
public:
	int data;
	Node* next;
};

void PrintLinkedList(Node* head)
{
	Node* temp = head;
	while (temp != nullptr) {
		cout << temp->data << " ";
		temp = temp->next;
	}
	cout << endl;
}

int main()
{
	Node* head = nullptr;
	Node* second = nullptr;
	Node* third = nullptr;

	head = new Node();
	second = new Node();
	third = new Node();

	head->data = 1;
	head->next = second;
	
	second->data = 2;
	second->next = third;
	
	third->data = 3;
	third->next = nullptr;


	PrintLinkedList(head);

	delete head;
	delete second;
	delete third;
	return 0;
}
\end{lstlisting}
\noindent
\fbox{%
  \parbox{0.3\textwidth}{
\textbf{output}:\\
1 2 3
}}

Example\_3: 链表插入节点

{\color{red}{\emph{linked list example\_3 code}}}
\begin{lstlisting}
#include <iostream>

using namespace std;

class Node{
public:
	int data;
	Node* next;
};

// 在链表前面插入节点
void push(Node** head_ref, int newData)
{
	Node* newNode = new Node();
	newNode->data = newData;
	newNode->next = (*head_ref);
	(*head_ref) = newNode;
}

// 在节点后面插入节点
void insertAfter(Node** prev_node, int newData)
{
	if ((*prev_node) == nullptr) {
		cout << "the previous node cannot be nullptr" << endl;
		return;
	}

	Node* newNode = new Node();
	newNode->data = newData;
	newNode->next = (*prev_node)->next;
	(*prev_node)->next = newNode;
}

// 在尾节点后插入节点
void append(Node** head_ref, int newData)
{
	Node* newNode = new Node();
	newNode->data = newData;
	newNode->next = nullptr;
	if ((*head_ref) == nullptr) {
		(*head_ref) = newNode;
		return;
	}

	Node* move = (*head_ref);
	while (move->next != nullptr) {
		move = move->next;
	}
	move->next = newNode;
}

// 打印链表
void PrintLinkedList(Node* head)
{
	Node* temp = head;
	while (temp != nullptr) {
		cout << temp->data << " ";
		temp = temp->next;
	}
	cout << endl;
}

void destroyLinkedList(Node** head_ref) {
	Node* move = (*head_ref);
	Node* next = nullptr;
	while (move != nullptr) {
		next = move->next;
		delete move;
		move = next;
	}
	(*head_ref) = nullptr;
}

int main()
{
	Node* head = nullptr;
	
	append(&head, 6);

	push(&head, 7);

	push(&head, 1);

	append(&head, 4);

	insertAfter(&(head->next), 8);

	cout << "linked list is: ";
	PrintLinkedList(head);
	destroyLinkedList(&head);
	return 0;
}
\end{lstlisting}
\noindent
\fbox{%
  \parbox{0.3\textwidth}{
\textbf{output}:\\
linked list is: 1 7 8 6 4
}}


\subsection{解题代码}
\begin{lstlisting}
null
\end{lstlisting}






\section{无重复字符的最长子串 (double pointer algorithm, set)}
\definibox{问题描述}{
\noindent 给定一个字符串, 请你找出其中不含有重复字符的最长子串的长度.

\noindent \textbf{示例1}:

\noindent 输入: ``abcabcb"

\noindent 输出: 3

\noindent 解释: 因为无重复字符的最长子串是 ``abc", 所以其长度为 3.

\noindent \textbf{示例 2}:

\noindent 输入: ``bbbbb"

\noindent 输出: 1

\noindent 解释: 因为无重复字符的最长子串是 ``b", 所以其长度为 1.

\noindent \textbf{示例 3}:

\noindent 输入: ``pwwkew"

\noindent 输出: 3

\noindent 解释: 因为无重复字符的最长子串是``wke", 所以其长度为3. 请注意, 你的答案必须是子串的长度, ``pwke"是一个子序列, 不是子串.

\noindent \url{https://leetcode-cn.com/problems/longest-substring-without-repeating-characters}
}

\subsection{解题思路}

\url{https://cloud.tencent.com/developer/article/1377650}

这道题主要用到思路是: 滑动窗口

什么是滑动窗口?

其实就是一个队列, 比如例题中的abcabcbb, 进入这个队列(窗口)为abc满足题目要求, 当再进入a, 队列变成了abca, 这时候不满足要求. 所以, 我们要移动这个队列!

如何移动?

我们只要把队列的左边的元素移出就行了, 直到满足题目要求!

一直维持这样的队列, 找出队列出现最长的长度时候, 求出解!

时间复杂度: \textbf{O(n)}



\subsection{解题代码}
\begin{lstlisting}
#include <iostream>
#include <string>
#include <unordered_set>
#include <algorithm> // max, min

using namespace std;

int lengthOfLongestSubstring(string s) {
	if (s.size() == 0) return 0;
	unordered_set<char> lookup;
	int maxStr = 0;
	int left = 0;
	for (int i = 0; i < s.size(); i++) {
		while (lookup.find(s[i]) != lookup.end()) {
			lookup.erase(s[left]);
			left++;
		}
		maxStr = max(maxStr, i - left + 1);
		lookup.insert(s[i]);
	}
	return maxStr;
}

int main()
{
	string str = "abcabcb";
	cout << lengthOfLongestSubstring(str) << endl;
	return 0;
}
\end{lstlisting}
\noindent
\fbox{%
  \parbox{0.3\textwidth}{
\textbf{output}:\\
3
}}


