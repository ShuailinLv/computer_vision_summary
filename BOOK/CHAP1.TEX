\chapter{绪论}
\thispagestyle{empty}

\setlength{\fboxrule}{0pt}\setlength{\fboxsep}{0cm}
\noindent\color{blueblack}\shadowbox{
\begin{tabular}{|p{13.8cm}|}\arrayrulecolor{darkblue}\hline
\rowcolor{darkblue} \hei\textcolor{white}{Goals to Achieve}\\\hline
\rowcolor{lightblue}~~~~~~~~\kai\textcolor{darkblue}{1.~~ unordered\_map．}\\
%\rowcolor{lightblue}~~~~~~~~\kai\textcolor{darkblue}{2.~~ 了解数值计算方法的研究内容和特点．}\\
%\rowcolor{lightblue}~~~~~~~~\kai\textcolor{darkblue}{3.~~ 理解数值计算误差的有关概念．}\\
%\rowcolor{lightblue}~~~~~~~~\kai\textcolor{darkblue}{4.~~ 掌握数值计算误差的控制方法．}\\\hline
\end{tabular}}\color{black}
\setlength{\fboxrule}{1pt}\setlength{\fboxsep}{4pt}
%\setlength{\fboxrule}{0pt}\setlength{\fboxsep}{0cm}
%\shadowbox{
%\begin{tcolorbox}[arc=0mm,colback=white,colframe=darkblue,title= 学习目标与要求]
%\kai\textcolor{darkblue}{1.~~了解科学计算的一般过程．}\\
%\kai\textcolor{darkblue}{2.~~了解数值计算方法的研究内容和特点．}\\
%\kai\textcolor{darkblue}{3.~~理解数值计算误差的有关概念．}\\
%\kai\textcolor{darkblue}{4.~~掌握数值计算误差的控制方法．}
%\end{tcolorbox}}
%\setlength{\fboxrule}{1pt}\setlength{\fboxsep}{4pt}

\section{两数之和}
\definibox{问题描述}{
\noindent 给定一个整数数组\textbf{nums} 和一个目标值\textbf{target}, 请你在该数组中找出和为目标值的那两个整数, 并返回他们的数组下标. 你可以假设每种输入只会对应一个答案. 但是, 你不能重复利用这个数组中同样的元素.\\
示例: 给定 nums = [2, 7, 11, 15], target = 9; 因为 nums[0] + nums[1] = 2 + 7 = 9;

\noindent 所以返回 [0, 1]

\noindent \url{https://leetcode-cn.com/problems/two-sum}}
\subsection{解题思路}
这里用c++的unordered\_map来解决, unordered\_map内部是一个关联容器, 采用hash 表结构, 有快速检索的功能.

哈希表是通过key关键字直接访问对应value值的数据结构. 特点是键和值一一对应, 查找时间复杂度\textbf{O(1)}.

{\color{red}{\emph{unordered\_map example code}}}
\begin{lstlisting}
#include <iostream>
#include <unordered_map>
#include <string>
using namespace std;
int main()
{
	unordered_map<int, string> myMap = { { 5, "王五" },{ 6, "赵六" } };//使用{}赋值
	myMap[2] = "李二";  //使用[ ]进行单个插入，若已存在键值2，则赋值修改，若无则插入。
	myMap.insert(pair<int, string>(3, "张三"));//使用insert和pair插入
	myMap[1] = "陈一";
	//遍历输出	
	auto iter = myMap.begin();
	while (iter != myMap.end()) {
		cout << iter->first << "," << iter->second << endl;
		++iter;
	}

	//查找元素并输出
	auto iterator = myMap.find(2);//find()返回一个指向2的迭代器
	if (iterator != myMap.end())
		cout << endl << iterator->first << "," << iterator->second << endl;
	system("pause");
	return 0;
}
\end{lstlisting}

\subsection{解题代码}
\begin{lstlisting}
#include <iostream>
#include <unordered_map>
#include <vector>
using namespace std;

vector<int> twoSum(vector<int>& nums, int target)
{
    unordered_map<int, int> map;
    vector<int> result={};
    int n = (int)nums.size();
    for(int i = 0; i < n; ++i) {
        auto p = map.find(target-nums[i]);
        if(p != map.end()) {
        result.push_back(p->second);
        result.push_back(i);
        }
    map[nums[i]] = i;
    }
    return result;
}

int main()
{
    vector< int > nums = {2,7,11,15};
    vector<int> result;
    result = twoSum(nums,9);
    cout<<"["<<result[0] << "," <<result[1]<<"]"<<endl;
    return 0;
}
\end{lstlisting}
